# -*- coding: utf-8 -*-
"""
Этот модуль содержит функции для расчета продвинутых, кастомных индикаторов,
основанных на анализе микроструктуры рынка. Эти индикаторы предназначены для
выявления аномалий в поведении толпы, дисбалансов спроса и предложения,
и могут служить основой для построения сложных торговых стратегий.
"""
import pandas as pd
import numpy as np


def calculate_order_flow_delta(df: pd.DataFrame, window: int = 30) -> pd.Series:
    """
    Рассчитывает дельту потока ордеров (Order Flow Delta) за скользящее окно.

    Торговая идея:
    Дельта потока ордеров — это разница между объемом покупок и объемом продаж
    по рыночным ценам. Положительная дельта указывает на преобладание агрессивных
    покупателей, отрицательная — на преобладание агрессивных продавцов.
    Резкие изменения дельты могут сигнализировать о смене настроений на рынке
    и потенциальных разворотах или продолжении тренда.

    Особенности реализации:
    В идеале для расчета требуется информация об агрессоре в сделке (покупатель или
    продавец инициировал сделку). Поскольку в данных `agg_trades` этой информации
    нет, мы используем эвристику (прокси):
    - Если цена выросла по сравнению с предыдущей сделкой, считаем объем покупкой.
    - Если цена упала — продажей.
    - Если не изменилась — объем равен нулю.
    Это упрощение, но оно дает достаточно хорошее приближение к реальной дельте.

    Args:
        df (pd.DataFrame): DataFrame с данными о сделках, должен содержать
                           колонки 'price' и 'quantity'.
        window (int): Размер скользящего окна для суммирования дельты.

    Returns:
        pd.Series: Временной ряд с рассчитанной дельтой потока ордеров.
    """
    print("Calculating Order Flow Delta (Proxy)...")

    # 1. Определяем направление сделки по изменению цены
    price_change = df['price'].diff()

    # 2. Рассчитываем "дельту" для каждой сделки.
    # np.where - это векторизованный аналог if/elif/else.
    delta = np.where(
        price_change > 0, df['quantity'],         # Если цена выросла - объем со знаком "+"
        np.where(price_change < 0, -df['quantity'], 0)  # Если упала - объем со знаком "-"
    )

    # 3. Преобразуем массив numpy в pandas Series для дальнейших операций
    delta_series = pd.Series(delta, index=df.index)

    # 4. Суммируем дельту за скользящее окно и присваиваем имя для колонки
    return delta_series.rolling(window=window).sum().rename("order_flow_delta")


def calculate_cascade_exhaustion(liquidations_df: pd.DataFrame, window: str = '5min') -> pd.Series:
    """
    Рассчитывает индикатор "Истощение Каскада" ликвидаций.

    Торговая идея:
    Каскадные ликвидации (когда закрытие одних позиций вызывает движение цены,
    которое провоцирует закрытие следующих) создают сильные, но краткосрочные
    тренды. Этот индикатор измеряет интенсивность ликвидаций. Когда после
    сильного всплеска интенсивность начинает падать (истощаться), это может
    сигнализировать об окончании каскада и скором развороте цены.

    Особенности реализации:
    В данной упрощенной версии индикатор просто считает количество ликвидаций
    в скользящем временном окне. В более сложной стратегии можно было бы
    сравнивать текущее значение со средним, искать пики и последующие спады.

    Args:
        liquidations_df (pd.DataFrame): DataFrame с данными о ликвидациях.
                                        Должен содержать колонку 'quantity'.
        window (str): Размер временного окна (например, '5min', '1H').

    Returns:
        pd.Series: Временной ряд с количеством ликвидаций в окне.
    """
    print("Calculating Cascade Exhaustion...")
    if liquidations_df.empty:
        return pd.Series(dtype=float)  # Возвращаем пустую серию с правильным типом

    # Считаем количество событий (ликвидаций) за скользящий временной интервал
    liquidation_counts = liquidations_df['quantity'].rolling(window).count()

    return liquidation_counts


def calculate_panic_index(df: pd.DataFrame, window: int = 30) -> pd.Series:
    """
    Рассчитывает "Индекс Паники Толпы".

    Торговая идея:
    Индекс пытается измерить уровень "паники" или "эйфории" на рынке. Паника
    часто характеризуется одновременным ростом волатильности (цена хаотично
    движется) и всплеском торгового объема (все пытаются закрыть позиции).
    Высокие значения индекса могут указывать на кульминацию движения (дно при
    панических продажах или вершину при эйфорических покупках), что часто
    предшествует развороту.

    Особенности реализации:
    Индекс является композитным и состоит из двух частей:
    1. Волатильность: Рассчитывается как стандартное отклонение логарифмических
       доходностей цены.
    2. Всплеск объема: Рассчитывается как процентное изменение суммарного объема
       в скользящем окне.
    Оба компонента нормализуются (приводятся к диапазону от 0 до 1), чтобы их
    можно было корректно сложить, и суммируются с весами (здесь 60% волатильность
    и 40% объем).

    Args:
        df (pd.DataFrame): DataFrame с данными о сделках.
        window (int): Размер скользящего окна для расчета компонентов.

    Returns:
        pd.Series: Временной ряд "Индекса Паники".
    """
    print("Calculating Panic Index...")

    # 1. Расчет волатильности
    # Используем логарифмическую доходность для большей стабильности расчетов
    log_returns = np.log(df['price'] / df['price'].shift(1))
    volatility = log_returns.rolling(window=window).std()

    # 2. Расчет всплеска объема
    volume_sum = df['quantity'].rolling(window=window).sum()
    # pct_change() вычисляет процентное изменение. Первое значение всегда будет NaN,
    # так как нет предыдущего значения для сравнения. Заполняем его нулем.
    volume_roc = volume_sum.pct_change().fillna(0)

    # 3. Нормализация компонентов
    # Чтобы сложить две разные по своей природе величины, их нужно привести
    # к одному масштабу. Здесь мы используем Min-Max нормализацию.
    # Добавляем эпсилон (1e-9) в знаменатель, чтобы избежать деления на ноль,
    # если все значения в окне будут одинаковыми (например, волатильность равна 0).
    vol_range = volatility.max() - volatility.min()
    norm_volatility = (volatility - volatility.min()) / (vol_range + 1e-9)

    vol_roc_range = volume_roc.max() - volume_roc.min()
    norm_volume_roc = (volume_roc - volume_roc.min()) / (vol_roc_range + 1e-9)

    # 4. Финальный индекс как взвешенное среднее
    panic_index = (norm_volatility * 0.6 + norm_volume_roc * 0.4)

    return panic_index.rename("panic_index")


def calculate_absorption_strength(df: pd.DataFrame, window: int = 50) -> pd.Series:
    """
    Рассчитывает "Силу Поглощения" (Absorption Strength).

    Торговая идея:
    Поглощение — это ситуация, когда крупные участники рынка "поглощают"
    большой объем продаж или покупок, не давая цене сильно измениться.
    Например, если на рынок выливается большой объем продаж, а цена почти не
    падает, это значит, что на этих уровнях стоит крупный покупатель, который
    все скупает. Обнаружение такого поглощения может быть сильным сигналом
    о наличии поддержки (при поглощении продаж) или сопротивления (при
    поглощении покупок).

    Особенности реализации:
    Это прокси-индикатор, основанный на следующей логике:
    - Рассчитывается накопленная дельта потока ордеров (см. `calculate_order_flow_delta`).
    - Рассчитывается диапазон изменения цены (max - min) за то же окно.
    - Сила поглощения = Накопленная дельта / Диапазон цены.
    Если дельта сильно отрицательная (много продавали), а диапазон цены мал,
    знаменатель будет маленьким, и итоговое значение будет большим по модулю
    и отрицательным. Это и есть сигнал сильного поглощения продаж.

    Args:
        df (pd.DataFrame): DataFrame с данными о сделках.
        window (int): Размер скользящего окна для расчета.

    Returns:
        pd.Series: Временной ряд "Силы Поглощения".
    """
    print("Calculating Absorption Strength (Proxy)...")

    # 1. Рассчитываем дельту объема (аналогично order_flow_delta)
    price_diff = df['price'].diff()
    volume_delta = np.where(price_diff > 0, df['quantity'],
                            np.where(price_diff < 0, -df['quantity'], 0))
    volume_delta = pd.Series(volume_delta, index=df.index)

    # 2. Накопленная дельта за окно
    cumulative_delta = volume_delta.rolling(window=window).sum()

    # 3. Диапазон изменения цены за то же окно
    price_range = df['price'].rolling(window=window).max() - df['price'].rolling(window=window).min()

    # 4. Расчет силы поглощения.
    # Добавляем эпсилон, чтобы избежать деления на ноль, если цена не менялась.
    absorption = cumulative_delta / (price_range + 1e-9)

    return absorption.rename("absorption_strength")
